package main

import (
	"fmt"
	"time"
)

func main() {
	c1 := make(chan string)
	c2 := make(chan string)

	go func() {
		for {
			c1 <- "from 1"
			time.Sleep(time.Second * 2)
		}
	}()
	go func() {
		for {
			c2 <- "from 2"
			time.Sleep(time.Second * 3)
		}
	}()
	go func() {
		for {
			//Обычно select используется для таймеров:
			select {
			case msg1 := <-c1:
				fmt.Println("Message 1", msg1)
			case msg2 := <-c2:
				fmt.Println("Message 2", msg2)
			case <-time.After(time.Second):
				fmt.Println("timeout")
				/*
								 как только запускается селект, он запускает After чтобы узнать что за канал она вернет
									After делает новый канал с буфером 1, запускает рутину которая ждет тот интервал и
									отдает канал тебе
									по истечению интервала рутина передаст в канал текущее время
									и селект тогда может пройти по тому case если он еще не прошел по другому
									очень полезная тема
									func After(dt time.Duration) <-chan time.Time {
										ch := make(chan time.Time, 1)
										go func(){
										time.Sleep(dt)
										ch <- time.Now()
									}()
									return ch
								}

				Если ты знаешь что рутина может не ответить по какой-то причине, либо ты хочешь забрать
				 результат позже или просто отложить какое-то действие, то используют такую штуку
				*/
			default:
				// Также мы можем задать команды, которые выполняются по умолчанию, используя конструкцию default
				fmt.Println("nothing ready")
			}
		}
	}()

	var input string
	fmt.Scanln(&input)
}

/*
 Эта программа выводит «from 1» каждые 2 секунды и «from 2» каждые 3 секунды.
 Оператор select выбирает первый готовый канал, и получает сообщение из него,
 или же передает сообщение через него. Когда готовы несколько каналов, получение
 сообщения происходит из случайно выбранного готового канала. Если же ни один из
 каналов не готов, оператор блокирует ход программы до тех пор, пока какой-либо из
 каналов будет готов к отправке или получению.
*/
