package main

import (
	"fmt"
	"time"
)

/*
Каналы обеспечивают возможность общения нескольких горутин друг с другом,
чтобы синхронизировать их выполнение.
*/
func pinger2(c chan string) {
	for i := 0; ; i++ {
		c <- "ping"
	}
}

func printer2(c chan string) {
	for {
		msg := <-c
		fmt.Println(msg)
		time.Sleep(time.Second * 1)
	}
}

func main() {
	var c chan string = make(chan string)
	/*
	    Данное использование каналов позволяет синхронизировать две горутины.
	   Когда pinger пытается послать сообщение в канал, он ожидает, пока printer будет готов
	    получить сообщение. Такое поведение называется блокирующим. Давайте добавим ещё одного
	    отправителя сообщений в программу и посмотрим, что будет. Добавим эту функцию ponger.
	    Теперь программа будет выводить на экран то ping, то pong по очереди.
	*/
	go pinger2(c)
	go ponger(c)
	go printer2(c)

	var input string
	fmt.Scanln(&input)
}

/*
 Программа будет постоянно выводить «ping» (нажмите enter, чтобы её остановить).
 Тип канала представлен ключевым словом chan, за которым следует тип, который будет
 передаваться по каналу (в данном случае мы передаем строки). Оператор <- (стрелка влево)
 используется для отправки и получения сообщений по каналу. Конструкция c <- "ping"
 означает отправку "ping", а msg := <- c — его получение и сохранение в переменную msg.
 Строка с fmt может быть записана другим способом: fmt.Println(<-c), тогда можно было
 бы удалить предыдущую строку.
*/

func ponger(c chan string) {
	for i := 0; ; i++ {
		c <- "pong"
	}
}

/*
	func pinger(c chan<- string) - канал только принимающий
	func printer(c <-chan string) - канал только отправляющий

	Существуют и двунаправленные каналы, которые могут быть переданы в функцию,
	принимающую только принимающие или отправляющие каналы. Но только отправляющие
	или принимающие каналы не могут быть переданы в функцию, требующую двунаправленного канала!
*/
